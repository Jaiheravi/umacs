;;; cl-loaddefs.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:



;;; Generated autoloads from cl-extra.el

(autoload 'cl-coerce "cl-extra"
"Coerce OBJECT to type TYPE.
TYPE is a Common Lisp type specifier.

(fn OBJECT TYPE)")
(autoload 'cl-equalp "cl-extra"
"Return t if two Lisp objects have similar structures and contents.
This is like `equal', except that it accepts numerically equal
numbers of different types (float vs. integer), and also compares
strings case-insensitively.

(fn X Y)")
(function-put 'cl-equalp 'side-effect-free 'error-free)
(autoload 'cl--mapcar-many "cl-extra"
"

(fn FUNC SEQS &optional ACC)")
(defsubst cl-map (type func seq &rest rest)
"Map a FUNCTION across one or more SEQUENCEs, returning a sequence.
TYPE is the sequence type to return.

(fn TYPE FUNCTION SEQUENCE...)" (declare (important-return-value t)) (let ((res (apply 'cl-mapcar func seq rest))) (and type (cl-coerce res type))))
(autoload 'cl-maplist "cl-extra"
"Map FUNCTION to each sublist of LIST or LISTs.
Like `cl-mapcar', except applies to lists and their cdr's rather than to
the elements themselves.

(fn FUNCTION LIST...)")
(function-put 'cl-maplist 'important-return-value 't)
(autoload 'cl-mapc "cl-extra"
"Like `cl-mapcar', but does not accumulate values returned by the function.

(fn FUNCTION SEQUENCE...)")
(autoload 'cl-mapl "cl-extra"
"Like `cl-maplist', but does not accumulate values returned by the function.

(fn FUNCTION LIST...)")
(autoload 'cl-mapcan "cl-extra"
"Like `cl-mapcar', but nconc's together the values returned by the function.

(fn FUNCTION SEQUENCE...)")
(function-put 'cl-mapcan 'important-return-value 't)
(autoload 'cl-mapcon "cl-extra"
"Like `cl-maplist', but nconc's together the values returned by the function.

(fn FUNCTION LIST...)")
(function-put 'cl-mapcon 'important-return-value 't)
(autoload 'cl-some "cl-extra"
"Say whether PREDICATE is true for any element in the SEQ sequences.
More specifically, the return value of this function will be the
same as the first return value of PREDICATE where PREDICATE has a
non-nil value.


(fn PREDICATE SEQ...)")
(function-put 'cl-some 'important-return-value 't)
(autoload 'cl-every "cl-extra"
"Return true if PREDICATE is true of every element of SEQ or SEQs.

(fn PREDICATE SEQ...)")
(function-put 'cl-every 'important-return-value 't)
(defsubst cl-notany (pred seq &rest rest)
"Return true if PREDICATE is false of every element of SEQ or SEQs.

(fn PREDICATE SEQ...)" (declare (important-return-value t)) (not (apply #'cl-some pred seq rest)))
(defsubst cl-notevery (pred seq &rest rest)
"Return true if PREDICATE is false of some element of SEQ or SEQs.

(fn PREDICATE SEQ...)" (declare (important-return-value t)) (not (apply #'cl-every pred seq rest)))
(autoload 'cl--map-keymap-recursively "cl-extra"
"

(fn FUNC-REC MAP &optional BASE)")
(autoload 'cl--map-intervals "cl-extra"
"

(fn FUNC &optional WHAT PROP START END)")
(autoload 'cl--map-overlays "cl-extra"
"

(fn FUNC &optional BUFFER START END ARG)")
(autoload 'cl--set-frame-visible-p "cl-extra"
"

(fn FRAME VAL)")
(autoload 'cl-gcd "cl-extra"
"Return the greatest common divisor of the arguments.

(fn &rest ARGS)")
(function-put 'cl-gcd 'side-effect-free 't)
(autoload 'cl-lcm "cl-extra"
"Return the least common multiple of the arguments.

(fn &rest ARGS)")
(function-put 'cl-lcm 'side-effect-free 't)
(autoload 'cl-isqrt "cl-extra"
"Return the integer square root of the (integer) argument X.

(fn X)")
(function-put 'cl-isqrt 'side-effect-free 't)
(autoload 'cl-floor "cl-extra"
"Return a list of the floor of X and the fractional part of X.
With two arguments, return floor and remainder of their quotient.

(fn X &optional Y)")
(function-put 'cl-floor 'side-effect-free 't)
(autoload 'cl-ceiling "cl-extra"
"Return a list of the ceiling of X and the fractional part of X.
With two arguments, return ceiling and remainder of their quotient.

(fn X &optional Y)")
(function-put 'cl-ceiling 'side-effect-free 't)
(autoload 'cl-truncate "cl-extra"
"Return a list of the integer part of X and the fractional part of X.
With two arguments, return truncation and remainder of their quotient.

(fn X &optional Y)")
(function-put 'cl-truncate 'side-effect-free 't)
(autoload 'cl-round "cl-extra"
"Return a list of X rounded to the nearest integer and the remainder.
With two arguments, return rounding and remainder of their quotient.

(fn X &optional Y)")
(function-put 'cl-round 'side-effect-free 't)
(autoload 'cl-mod "cl-extra"
"The remainder of X divided by Y, with the same sign as Y.

(fn X Y)")
(function-put 'cl-mod 'side-effect-free 't)
(autoload 'cl-rem "cl-extra"
"The remainder of X divided by Y, with the same sign as X.

(fn X Y)")
(function-put 'cl-rem 'side-effect-free 't)
(autoload 'cl-signum "cl-extra"
"Return 1 if X is positive, -1 if negative, 0 if zero.

(fn X)")
(function-put 'cl-signum 'side-effect-free 't)
(autoload 'cl-parse-integer "cl-extra"
"Parse integer from the substring of STRING from START to END.
STRING may be surrounded by whitespace chars (chars with syntax ` ').
Other non-digit chars are considered junk.
RADIX is an integer between 2 and 36, the default is 10.  Signal
an error if the substring between START and END cannot be parsed
as an integer unless JUNK-ALLOWED is non-nil.

(fn STRING &key START END RADIX JUNK-ALLOWED)")
(function-put 'cl-parse-integer 'side-effect-free 't)
 (autoload 'cl-random-state-p "cl-extra")
 (function-put 'cl-random-state-p 'side-effect-free 'error-free)
(autoload 'cl-random "cl-extra"
"Return a pseudo-random nonnegative number less than LIM, an integer or float.
Optional second arg STATE is a random-state object.

(fn LIM &optional STATE)")
(autoload 'cl-make-random-state "cl-extra"
"Return a copy of random-state STATE, or of the internal state if omitted.
If STATE is t, return a new state object seeded from the time of day.

(fn &optional STATE)")
(autoload 'cl-float-limits "cl-extra"
"Initialize the Common Lisp floating-point parameters.
This sets the values of: `cl-most-positive-float', `cl-most-negative-float',
`cl-least-positive-float', `cl-least-negative-float', `cl-float-epsilon',
`cl-float-negative-epsilon', `cl-least-positive-normalized-float', and
`cl-least-negative-normalized-float'.")
(autoload 'cl-subseq "cl-extra"
"Return the subsequence of SEQ from START to END.
If END is omitted, it defaults to the length of the sequence.
If START or END is negative, it counts from the end.
Signal an error if START or END are outside of the sequence (i.e
too large if positive or too small if negative).

(fn SEQ START &optional END)")
(function-put 'cl-subseq 'side-effect-free 't)
(autoload 'cl-concatenate "cl-extra"
"Concatenate, into a sequence of type TYPE, the argument SEQUENCEs.

(fn TYPE SEQUENCE...)")
(defsubst cl-revappend (x y)
"Equivalent to (append (reverse X) Y)." (declare (side-effect-free t)) (nconc (reverse x) y))
(defsubst cl-nreconc (x y)
"Equivalent to (nconc (nreverse X) Y)." (declare (important-return-value t)) (nconc (nreverse x) y))
(autoload 'cl-list-length "cl-extra"
"Return the length of list X.  Return nil if list is circular.

(fn X)")
(function-put 'cl-list-length 'side-effect-free 't)
(autoload 'cl-tailp "cl-extra"
"Return true if SUBLIST is a tail of LIST.

(fn SUBLIST LIST)")
(autoload 'cl-get "cl-extra"
"Return the value of SYMBOL's PROPNAME property, or DEFAULT if none.

(fn SYMBOL PROPNAME &optional DEFAULT)")
(function-put 'cl-get 'side-effect-free 't)
(function-put 'cl-get 'compiler-macro #'cl--compiler-macro-get)
(autoload 'cl-getf "cl-extra"
"Search PROPLIST for property PROPNAME; return its value or DEFAULT.
PROPLIST is a list of the sort returned by `symbol-plist'.

(fn PROPLIST PROPNAME &optional DEFAULT)")
(function-put 'cl-getf 'side-effect-free 't)
(autoload 'cl--set-getf "cl-extra"
"

(fn PLIST TAG VAL)")
(autoload 'cl--do-remf "cl-extra"
"

(fn PLIST TAG)")
(autoload 'cl-remprop "cl-extra"
"Remove from SYMBOL's plist the property PROPNAME and its value.

(fn SYMBOL PROPNAME)")
(autoload 'cl-fresh-line "cl-extra"
"Output a newline unless already at the beginning of a line.

(fn &optional STREAM)")
(autoload 'cl-prettyexpand "cl-extra"
"Expand macros in FORM and insert the pretty-printed result.

(fn FORM &optional FULL)")
(set-advertised-calling-convention 'cl-prettyexpand '(form) '"27.1")
(autoload 'cl-find-class "cl-extra"
"Return CL class of TYPE.

Call `cl--find-class' to get TYPE's propname `cl--class'

(fn TYPE)")
(autoload 'cl-describe-type "cl-extra"
"Display the documentation for type TYPE (a symbol).

(fn TYPE &optional BUF FRAME)" t)
(autoload 'cl--derived-type-generalizers "cl-extra"
"

(fn TYPE)")


;;; Generated autoloads from cl-macs.el

(autoload 'cl--compiler-macro-list* "cl-macs"
"

(fn FORM ARG &rest OTHERS)")
(define-obsolete-function-alias 'cl--compiler-macro-cXXr #'internal--compiler-macro-cXXr "25.1")
(autoload 'cl-gensym "cl-macs"
"Generate a new uninterned symbol.
The name is made by appending a number to PREFIX, default \"G\".

(fn &optional PREFIX)")
(make-obsolete 'cl-gensym 'gensym "31.1")
(autoload 'cl-gentemp "cl-macs"
"Generate a new interned symbol with a unique name.
The name is made by appending a number to PREFIX, default \"T\".

(fn &optional PREFIX)")
(autoload 'cl-defun "cl-macs"
"Define NAME as a function.
Like normal `defun', except ARGLIST allows full Common Lisp conventions,
and BODY is implicitly surrounded by (cl-block NAME ...).

The full form of a Common Lisp function argument list is

   (VAR...
    [&optional (VAR [INITFORM [SVAR]])...]
    [&rest|&body VAR]
    [&key (([KEYWORD] VAR) [INITFORM [SVAR]])... [&allow-other-keys]]
    [&aux (VAR [INITFORM])...])

VAR may be replaced recursively with an argument list for
destructuring, `&whole' is supported within these sublists.  If
SVAR, INITFORM, and KEYWORD are all omitted, then `(VAR)' may be
written simply `VAR'.  See the Info node `(cl)Argument Lists' for
more details.

(fn NAME ARGLIST [DOCSTRING] BODY...)" nil t)
(function-put 'cl-defun 'doc-string-elt 3)
(function-put 'cl-defun 'autoload-macro 'expand)
(autoload 'cl-iter-defun "cl-macs"
"Define NAME as a generator function.
Like normal `iter-defun', except ARGLIST allows full Common Lisp conventions,
and BODY is implicitly surrounded by (cl-block NAME ...).

(fn NAME ARGLIST [DOCSTRING] BODY...)" nil t)
(function-put 'cl-iter-defun 'doc-string-elt 3)
(function-put 'cl-iter-defun 'autoload-macro 'expand)
(autoload 'cl-defmacro "cl-macs"
"Define NAME as a macro.
Like normal `defmacro', except ARGLIST allows full Common Lisp conventions,
and BODY is implicitly surrounded by (cl-block NAME ...).

The full form of a Common Lisp macro argument list is

   (VAR...
    [&optional (VAR [INITFORM [SVAR]])...]
    [&rest|&body VAR]
    [&key (([KEYWORD] VAR) [INITFORM [SVAR]])... [&allow-other-keys]]
    [&aux (VAR [INITFORM])...]
    [&environment VAR])

VAR may be replaced recursively with an argument list for
destructuring, `&whole' is supported within these sublists.  If
SVAR, INITFORM, and KEYWORD are all omitted, then `(VAR)' may be
written simply `VAR'.  See the Info node `(cl)Argument Lists' for
more details.

(fn NAME ARGLIST [DOCSTRING] BODY...)" nil t)
(function-put 'cl-defmacro 'doc-string-elt 3)
(function-put 'cl-defmacro 'autoload-macro 'expand)
(autoload 'cl-function "cl-macs"
"Introduce a function.
Like normal `function', except that if argument is a lambda form,
its argument list allows full Common Lisp conventions.

(fn FUNC)" nil t)
(autoload 'cl-destructuring-bind "cl-macs"
"Bind the variables in ARGS to the result of EXPR and execute BODY.

(fn ARGS EXPR &rest BODY)" nil t)
(autoload 'cl-eval-when "cl-macs"
"Control when BODY is evaluated.
If `compile' is in WHEN, BODY is evaluated when compiled at top-level.
If `load' is in WHEN, BODY is evaluated when loaded after top-level compile.
If `eval' is in WHEN, BODY is evaluated when interpreted or at non-top-level.

(fn (WHEN...) BODY...)" nil t)
(autoload 'cl-load-time-value "cl-macs"
"Like `progn', but evaluates the body at load time.
The result of the body appears to the compiler as a quoted constant.

(fn FORM &optional READ-ONLY)" nil t)
(autoload 'cl-case "cl-macs"
"Eval EXPR and choose among clauses on that value.
Each clause looks like (KEYLIST BODY...).  EXPR is evaluated and
compared against each key in each KEYLIST; the corresponding BODY
is evaluated.  If no clause succeeds, this macro returns nil.  A
single non-nil atom may be used in place of a KEYLIST of one
atom.  A KEYLIST of t or `otherwise' is allowed only in the final
clause, and matches if no other keys match.  Key values are
compared by `eql'.

(fn EXPR (KEYLIST BODY...)...)" nil t)
(autoload 'cl-ecase "cl-macs"
"Like `cl-case', but error if no case fits.
`otherwise'-clauses are not allowed.

(fn EXPR (KEYLIST BODY...)...)" nil t)
(autoload 'cl-typecase "cl-macs"
"Eval EXPR and choose among clauses on that value.
Each clause looks like (TYPE BODY...).  EXPR is evaluated and, if it
satisfies TYPE, the corresponding BODY is evaluated.  If no clause succeeds,
this macro returns nil.  A TYPE of t or `otherwise' is allowed only in the
final clause, and matches if no other keys match.

(fn EXPR (TYPE BODY...)...)" nil t)
(autoload 'cl-etypecase "cl-macs"
"Like `cl-typecase', but error if no case fits.
`otherwise'-clauses are not allowed.

(fn EXPR (TYPE BODY...)...)" nil t)
(autoload 'cl-block "cl-macs"
"Define a lexically-scoped block named NAME.
NAME may be any symbol.  Code inside the BODY forms can call `cl-return-from'
to jump prematurely out of the block.  This differs from `catch' and `throw'
in two respects:  First, the NAME is an unevaluated symbol rather than a
quoted symbol or other form; and second, NAME is lexically rather than
dynamically scoped:  Only references to it within BODY will work.  These
references may appear inside macro expansions, but not inside functions
called from BODY.

(fn NAME &rest BODY)" nil t)
(autoload 'cl-return "cl-macs"
"Return from the block named nil.
This is equivalent to `(cl-return-from nil RESULT)'.

(fn &optional RESULT)" nil t)
(autoload 'cl-return-from "cl-macs"
"Return from the block named NAME.
This jumps out to the innermost enclosing `(cl-block NAME ...)' form,
returning RESULT from that form (or nil if RESULT is omitted).
This is compatible with Common Lisp, but note that `defun' and
`defmacro' do not create implicit blocks as they do in Common Lisp.

(fn NAME &optional RESULT)" nil t)
(autoload 'cl-loop "cl-macs"
"The Common Lisp `loop' macro.
Valid clauses include:
  For clauses:
    for VAR from/upfrom/downfrom EXPR1 to/upto/downto/above/below EXPR2
        [by EXPR3]
    for VAR = EXPR1 then EXPR2
    for VAR in/on/in-ref LIST [by FUNC]
    for VAR across/across-ref ARRAY
    for VAR being:
      the elements of/of-ref SEQUENCE [using (index VAR2)]
      the symbols [of OBARRAY]
      the hash-keys/hash-values of HASH-TABLE [using (hash-values/hash-keys V2)]
      the key-codes/key-bindings/key-seqs of KEYMAP [using (key-bindings VAR2)]
      the overlays/intervals [of BUFFER] [from POS1] [to POS2]
      the frames/buffers
      the windows [of FRAME]
  Iteration clauses:
    repeat INTEGER
    while/until/always/never/thereis CONDITION
  Accumulation clauses:
    collect/append/nconc/concat/vconcat/count/sum/maximize/minimize FORM
      [into VAR]
  Miscellaneous clauses:
    with VAR = INIT
    if/when/unless COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...]
    named NAME
    initially/finally [do] EXPRS...
    do EXPRS...
    [finally] return EXPR

For more details, see Info node `(cl)Loop Facility'.

(fn CLAUSE...)" nil t)
(autoload 'cl-do "cl-macs"
"Bind variables and run BODY forms until END-TEST returns non-nil.
First, each VAR is bound to the associated INIT value as if by a `let' form.
Then, in each iteration of the loop, the END-TEST is evaluated; if true,
the loop is finished.  Otherwise, the BODY forms are evaluated, then each
VAR is set to the associated STEP expression (as if by a `cl-psetq' form)
and the next iteration begins.

Once the END-TEST becomes true, the RESULT forms are evaluated (with
the VARs still bound to their values) to produce the result
returned by `cl-do'.

Note that the entire loop is enclosed in an implicit nil block, so
that you can use `cl-return' to exit at any time.

Also note that END-TEST is checked before evaluating BODY.  If END-TEST
is initially non-nil, `cl-do' will exit without running BODY.

For more details, see `cl-do' description in Info node `(cl) Iteration'.

(fn ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)" nil t)
(autoload 'cl-do* "cl-macs"
"Bind variables and run BODY forms until END-TEST returns non-nil.
First, each VAR is bound to the associated INIT value as if by a `let*' form.
Then, in each iteration of the loop, the END-TEST is evaluated; if true,
the loop is finished.  Otherwise, the BODY forms are evaluated, then each
VAR is set to the associated STEP expression (as if by a `setq'
form) and the next iteration begins.

Once the END-TEST becomes true, the RESULT forms are evaluated (with
the VARs still bound to their values) to produce the result
returned by `cl-do*'.

Note that the entire loop is enclosed in an implicit nil block, so
that you can use `cl-return' to exit at any time.

Also note that END-TEST is checked before evaluating BODY.  If END-TEST
is initially non-nil, `cl-do*' will exit without running BODY.

This is to `cl-do' what `let*' is to `let'.
For more details, see `cl-do*' description in Info node `(cl) Iteration'.

(fn ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)" nil t)
(autoload 'cl-dolist "cl-macs"
"Loop over a list.
Evaluate BODY with VAR bound to each `car' from LIST, in turn.
Then evaluate RESULT to get return value, default nil.
An implicit nil block is established around the loop.

(fn (VAR LIST [RESULT]) BODY...)" nil t)
(autoload 'cl-dotimes "cl-macs"
"Loop a certain number of times.
Evaluate BODY with VAR bound to successive integers from 0, inclusive,
to COUNT, exclusive.  Then evaluate RESULT to get return value, default
nil.

(fn (VAR COUNT [RESULT]) BODY...)" nil t)
(autoload 'cl-tagbody "cl-macs"
"Execute statements while providing for control transfers to labels.
Each element of LABELS-OR-STMTS can be either a label (integer or symbol)
or a `cons' cell, in which case it's taken to be a statement.
This distinction is made before performing macroexpansion.
Statements are executed in sequence left to right, discarding any return value,
stopping only when reaching the end of LABELS-OR-STMTS.
Any statement can transfer control at any time to the statements that follow
one of the labels with the special form (go LABEL).
Labels have lexical scope and dynamic extent.

(fn &rest LABELS-OR-STMTS)" nil t)
(autoload 'cl-prog "cl-macs"
"Run BODY like a `cl-tagbody' after setting up the BINDINGS.
Shorthand for (cl-block nil (let BINDINGS (cl-tagbody BODY)))

(fn BINDINGS &rest BODY)" nil t)
(autoload 'cl-prog* "cl-macs"
"Run BODY like a `cl-tagbody' after setting up the BINDINGS.
Shorthand for (cl-block nil (let* BINDINGS (cl-tagbody BODY)))

(fn BINDINGS &rest BODY)" nil t)
(autoload 'cl-do-symbols "cl-macs"
"Loop over all symbols.
Evaluate BODY with VAR bound to each interned symbol, or to each symbol
from OBARRAY.

(fn (VAR [OBARRAY [RESULT]]) BODY...)" nil t)
(autoload 'cl-do-all-symbols "cl-macs"
"Like `cl-do-symbols', but use the default obarray.

(fn (VAR [RESULT]) BODY...)" nil t)
(autoload 'cl-psetq "cl-macs"
"Set SYMs to the values VALs in parallel.
This is like `setq', except that all VAL forms are evaluated (in order)
before assigning any symbols SYM to the corresponding values.

(fn SYM VAL SYM VAL ...)" nil t)
(autoload 'cl-progv "cl-macs"
"Bind SYMBOLS to VALUES dynamically in BODY.
The forms SYMBOLS and VALUES are evaluated, and must evaluate to lists.
Each symbol in the first list is bound to the corresponding value in the
second list (or to nil if VALUES is shorter than SYMBOLS); then the
BODY forms are executed and their result is returned.  This is much like
a `let' form, except that the list of symbols can be computed at run-time.

(fn SYMBOLS VALUES &rest BODY)" nil t)
(autoload 'cl-flet "cl-macs"
"Make local function definitions.
Each definition can take the form (FUNC EXP) where FUNC is the function
name, and EXP is an expression that returns the function value to which
it should be bound, or it can take the more common form (FUNC ARGLIST
BODY...) which is a shorthand for (FUNC (lambda ARGLIST BODY))
where BODY is wrapped in a `cl-block' named FUNC.

FUNC is defined only within FORM, not BODY, so you can't write recursive
function definitions.  Use `cl-labels' for that.  See Info node
`(cl) Function Bindings' for details.

(fn ((FUNC ARGLIST BODY...) ...) FORM...)" nil t)
(autoload 'cl-flet* "cl-macs"
"Make local function definitions.
Like `cl-flet' but the definitions can refer to previous ones.

(fn ((FUNC ARGLIST BODY...) ...) FORM...)" nil t)
(autoload 'cl-labels "cl-macs"
"Make local (recursive) function definitions.

Each definition can take the form (FUNC EXP) where FUNC is the function
name, and EXP is an expression that returns the function value to which
it should be bound, or it can take the more common form (FUNC ARGLIST
BODY...) which is a shorthand for (FUNC (lambda ARGLIST BODY))
where BODY is wrapped in a `cl-block' named FUNC.

FUNC is in scope in any BODY or EXP, as well as in FORM, so you can write
recursive and mutually recursive function definitions, with the caveat
that EXPs are evaluated in sequence and you cannot call a FUNC before its
EXP has been evaluated.
See Info node `(cl) Function Bindings' for details.

(fn ((FUNC ARGLIST BODY...) ...) FORM...)" nil t)
(autoload 'cl-macrolet "cl-macs"
"Make temporary macro definitions.
This is like `cl-flet', but for macros instead of functions.

(fn ((NAME ARGLIST BODY...) ...) FORM...)" nil t)
(autoload 'cl-symbol-macrolet "cl-macs"
"Make symbol macro definitions.
Within the body FORMs, references to the variable NAME will be replaced
by EXPANSION, and (setq NAME ...) will act like (setf EXPANSION ...).

(fn ((NAME EXPANSION) ...) FORM...)" nil t)
(autoload 'cl-with-gensyms "cl-macs"
"Bind each of NAMES to an uninterned symbol and evaluate BODY.

(fn NAMES &rest BODY)" nil t)
(autoload 'cl-once-only "cl-macs"
"Generate code to evaluate each of NAMES just once in BODY.

This macro helps with writing other macros.  Each of NAMES is
either (NAME FORM) or NAME, which latter means (NAME NAME).
During macroexpansion, each NAME is bound to an uninterned
symbol.  The expansion evaluates each FORM and binds it to the
corresponding uninterned symbol.

For example, consider this macro:

    (defmacro my-cons (x)
      (cl-once-only (x)
        \\=`(cons ,x ,x)))

The call (my-cons (pop y)) will expand to something like this:

    (let ((g1 (pop y)))
      (cons g1 g1))

The use of `cl-once-only' ensures that the pop is performed only
once, as intended.

See also `macroexp-let2'.

(fn NAMES &rest BODY)" nil t)
(autoload 'cl-with-accessors "cl-macs"
"Use BINDINGS as function calls on INSTANCE inside BODY.

This macro helps when writing code that makes repeated use of the
accessor functions of a structure or object instance, such as those
created by `cl-defstruct' and `defclass'.

BINDINGS is a list of (NAME ACCESSOR) pairs.  Inside BODY, NAME is
treated as the function call (ACCESSOR INSTANCE) using
`cl-symbol-macrolet'.  NAME can be used with `setf' and `setq' as a
generalized variable.  Because of how the accessor is used,
`cl-with-accessors' can be used with any generalized variable that can
take a single argument, such as `car' and `cdr'.

See also the macro `with-slots' described in the Info
node `(eieio)Accessing Slots', which is similar, but uses slot names
instead of accessor functions.

(fn ((NAME ACCESSOR) ...) INSTANCE &rest BODY)" nil t)
(autoload 'cl-multiple-value-bind "cl-macs"
"Collect multiple return values.
FORM must return a list; the BODY is then executed with the first N elements
of this list bound (`let'-style) to each of the symbols SYM in turn.  This
is analogous to the Common Lisp `multiple-value-bind' macro, using lists to
simulate true multiple return values.  For compatibility, (cl-values A B C) is
a synonym for (list A B C).

(fn (SYM...) FORM BODY)" nil t)
(autoload 'cl-multiple-value-setq "cl-macs"
"Collect multiple return values.
FORM must return a list; the first N elements of this list are stored in
each of the symbols SYM in turn.  This is analogous to the Common Lisp
`multiple-value-setq' macro, using lists to simulate true multiple return
values.  For compatibility, (cl-values A B C) is a synonym for (list A B C).

(fn (SYM...) FORM)" nil t)
(define-obsolete-function-alias 'cl-locally #'progn "31.1")
(autoload 'cl-the "cl-macs"
"Return FORM.  If type-checking is enabled, assert that it is of TYPE.

(fn TYPE FORM)" nil t)
(or (assq 'cl-optimize defun-declarations-alist) (let ((x (list 'cl-optimize #'cl--optimize))) (push x macro-declarations-alist) (push x defun-declarations-alist)))
(autoload 'cl--optimize "cl-macs"
"Serve `cl-optimize' in function declarations.
Example:
  (defun foo (x)
    (declare (cl-optimize (speed 3) (safety 0)))
    x)

(fn F ARGS &rest QUALITIES)")
(autoload 'cl-declare "cl-macs"
"Declare SPECS about the current function while compiling.
For instance

  (cl-declare (warn 0))

will turn off byte-compile warnings in the function.
See Info node `(cl)Declarations' for details.

(fn &rest SPECS)" nil t)
(make-obsolete 'cl-declare 'defvar "31.1")
(autoload 'cl-psetf "cl-macs"
"Set PLACEs to the values VALs in parallel.
This is like `setf', except that all VAL forms are evaluated (in order)
before assigning any PLACEs to the corresponding values.

(fn PLACE VAL PLACE VAL ...)" nil t)
(autoload 'cl-remf "cl-macs"
"Remove TAG from property list PLACE.
PLACE may be a symbol, or any generalized variable allowed by `setf'.
The form returns true if TAG was found and removed, nil otherwise.

(fn PLACE TAG)" nil t)
(autoload 'cl-shiftf "cl-macs"
"Shift left among PLACEs.
Example: (cl-shiftf A B C) sets A to B, B to C, and returns the old A.
Each PLACE may be a symbol, or any generalized variable allowed by `setf'.

(fn PLACE... VAL)" nil t)
(autoload 'cl-rotatef "cl-macs"
"Rotate left among PLACEs.
Example: (cl-rotatef A B C) sets A to B, B to C, and C to A.  It returns nil.
Each PLACE may be a symbol, or any generalized variable allowed by `setf'.

(fn PLACE...)" nil t)
(autoload 'cl-letf "cl-macs"
"Temporarily bind to PLACEs.
This is the analogue of `let', but with generalized variables (in the
sense of `setf') for the PLACEs.  Each PLACE is set to the corresponding
VALUE, then the BODY forms are executed.  On exit, either normally or
because of a `throw' or error, the PLACEs are set back to their original
values.  Note that this macro is *not* available in Common Lisp.
As a special case, if `(PLACE)' is used instead of `(PLACE VALUE)',
the PLACE is not modified before executing BODY.

See info node `(cl) Modify Macros' for details.

(fn ((PLACE VALUE) ...) BODY...)" nil t)
(autoload 'cl-letf* "cl-macs"
"Temporarily bind to PLACEs.
Like `cl-letf' but where the bindings are performed one at a time,
rather than all at the end (i.e. like `let*' rather than like `let').

(fn BINDINGS &rest BODY)" nil t)
(autoload 'cl-callf "cl-macs"
"Set PLACE to (FUNC PLACE ARGS...).
FUNC should be an unquoted function name or a lambda expression.
PLACE may be a symbol, or any generalized variable allowed by
`setf'.

(fn FUNC PLACE &rest ARGS)" nil t)
(autoload 'cl-callf2 "cl-macs"
"Set PLACE to (FUNC ARG1 PLACE ARGS...).
Like `cl-callf', but PLACE is the second argument of FUNC, not the first.

(fn FUNC ARG1 PLACE ARGS...)" nil t)
(autoload 'cl-defsubst "cl-macs"
"Define NAME as a function.
Like `defun', except the function is automatically declared `inline' and
the arguments are immutable.
ARGLIST allows full Common Lisp conventions, and BODY is implicitly
surrounded by (cl-block NAME ...).
The function's arguments should be treated as immutable.

(fn NAME ARGLIST [DOCSTRING] BODY...)" nil t)
(autoload 'cl-defstruct "cl-macs"
"Define a struct type.
This macro defines a new data type called NAME that stores data
in SLOTs.  It defines a `make-NAME' constructor, a `copy-NAME'
copier, a `NAME-p' predicate, and slot accessors named `NAME-SLOT'.
You can use the accessors to set the corresponding slots, via `setf'.

NAME is usually a symbol, but may instead take the form (NAME
OPTIONS...), where each OPTION is either a single keyword
or (KEYWORD VALUE) where KEYWORD can be one of `:conc-name',
`:constructor', `:copier', `:predicate', `:type', `:named',
`:initial-offset', `:print-function', `:noinline', or `:include'.
See Info node `(cl)Structures' for the description of the
options.

The first element in SLOTS can be a doc string.

The rest of the elements in SLOTS is a list of SLOT elements,
each of which should either be a symbol, or take the form (SNAME
SDEFAULT SOPTIONS...), where SDEFAULT is the default value of
that slot and SOPTIONS are keyword-value pairs for that slot.

Supported keywords for slots are:
- `:read-only': If this has a non-nil value, that slot cannot be set via `setf'.
- `:documentation': this is a docstring describing the slot.
- `:type': the type of the field; currently only used for documentation.

To see the documentation for a defined struct type, use
\\[describe-symbol] or \\[cl-describe-type].

(fn NAME &optional DOCSTRING &rest SLOTS)" nil t)
(function-put 'cl-defstruct 'doc-string-elt 2)
(function-put 'cl-defstruct 'autoload-macro 'expand)
(autoload 'cl-struct--pcase-macroexpander "cl-macs"
"Pcase patterns that match cl-struct EXPVAL of type TYPE.
Elements of FIELDS can be of the form (NAME PAT) in which case the
contents of field NAME is matched against PAT, or they can be of
the form NAME which is a shorthand for (NAME NAME).

(fn TYPE &rest FIELDS)")
(define-symbol-prop 'cl-struct--pcase-macroexpander 'edebug-form-spec '(sexp &rest [&or (sexp pcase-PAT) sexp]))
(define-symbol-prop 'cl-struct 'pcase-macroexpander #'cl-struct--pcase-macroexpander)
(autoload 'cl-struct-sequence-type "cl-macs"
"Return the sequence used to build STRUCT-TYPE.
STRUCT-TYPE is a symbol naming a struct type.  Return values are
either `vector', `list' or nil (and the latter indicates a
`record' struct type.

(fn STRUCT-TYPE)")
(function-put 'cl-struct-sequence-type 'side-effect-free 't)
(function-put 'cl-struct-sequence-type 'pure 't)
(autoload 'cl-struct-slot-info "cl-macs"
"Return a list of slot names of struct STRUCT-TYPE.
Each entry is a list (SLOT-NAME . OPTS), where SLOT-NAME is a
slot name symbol and OPTS is a list of slot options given to
`cl-defstruct'.  Dummy slots that represent the struct name and
slots skipped by :initial-offset may appear in the list.

(fn STRUCT-TYPE)")
(function-put 'cl-struct-slot-info 'side-effect-free 't)
(function-put 'cl-struct-slot-info 'pure 't)
(autoload 'cl-struct-slot-offset "cl-macs"
"Return the offset of slot SLOT-NAME in STRUCT-TYPE.
The returned zero-based slot index is relative to the start of
the structure data type and is adjusted for any structure name
and :initial-offset slots.  Signal error if struct STRUCT-TYPE
does not contain SLOT-NAME.

(fn STRUCT-TYPE SLOT-NAME)")
(function-put 'cl-struct-slot-offset 'side-effect-free 't)
(function-put 'cl-struct-slot-offset 'pure 't)
(autoload 'cl-typep "cl-macs"
"Return t if VAL is of type TYPE, nil otherwise.

(fn VAL TYPE)")
(function-put 'cl-typep 'compiler-macro #'cl-typep--inliner)
(autoload 'cl-check-type "cl-macs"
"Verify that FORM is of type TYPE; signal an error if not.
STRING is an optional description of the desired type.

Hint: To check the type of an object, use `cl-type-of'.
To define new types, see `cl-deftype'.

(fn FORM TYPE &optional STRING)" nil t)
(autoload 'cl-assert "cl-macs"
"Verify that FORM returns non-nil; signal an error if not.
Second arg SHOW-ARGS means to include arguments of FORM in message.
Other args STRING and ARGS... are arguments to be passed to `error'.
They are not evaluated unless the assertion fails.  If STRING is
omitted, a default message listing FORM itself is used.

(fn FORM &optional SHOW-ARGS STRING &rest ARGS)" nil t)
(autoload 'cl-define-compiler-macro "cl-macs"
"Define a compiler-only macro.
This is like `defmacro', but macro expansion occurs only if the call to
FUNC is compiled (i.e., not interpreted).  Compiler macros should be used
for optimizing the way calls to FUNC are compiled; the form returned by
BODY should do the same thing as a call to the normal function called
FUNC, though possibly more efficiently.  Note that, like regular macros,
compiler macros are expanded repeatedly until no further expansions are
possible.  Unlike regular macros, BODY can decide to \"punt\" and leave the
original function call alone by declaring an initial `&whole foo' parameter
and then returning foo.

(fn FUNC ARGS &rest BODY)" nil t)
(autoload 'cl-compiler-macroexpand "cl-macs"
"Like `macroexpand', but for compiler macros.
Expands FORM repeatedly until no further expansion is possible.
Returns FORM unchanged if it has no compiler macro, or if it has a
macro that returns its `&whole' argument.

(fn FORM)")
(autoload 'cl--compiler-macro-adjoin "cl-macs"
"

(fn FORM A LIST &rest KEYS)")
(autoload 'cl-deftype "cl-macs"
"Define NAME as a new, so-called derived type.
The type NAME can then be used in `cl-typecase', `cl-check-type',
etc., and to some extent, as method specializer.

ARGLIST is a Common Lisp argument list of the sort accepted by
`cl-defmacro'.  BODY forms should return a type specifier that is equivalent
to the type (see the Info node `(cl)Type Predicates').

If there is a `declare' form in BODY, the spec (parents . PARENTS)
can specify a list of types NAME is a subtype of.
The list of PARENTS types determines the order of methods invocation,
and missing PARENTS may cause incorrect ordering of methods, while
extraneous PARENTS may cause use of extraneous methods.

If PARENTS is non-nil, ARGLIST must be nil.

(fn NAME ARGLIST &rest BODY)" nil t)
(function-put 'cl-deftype 'doc-string-elt 3)
(autoload 'cl-type--pcase-macroexpander "cl-macs"
"Pcase pattern that matches objects of TYPE.
TYPE is a type descriptor as accepted by `cl-typep', which see.

(fn TYPE)")
(define-symbol-prop 'cl-type--pcase-macroexpander 'edebug-form-spec 'nil)
(define-symbol-prop 'cl-type 'pcase-macroexpander #'cl-type--pcase-macroexpander)


;;; Generated autoloads from cl-seq.el

(autoload 'cl-endp "cl-seq"
"Return true if X is the empty list; false if it is a cons.
Signal an error if X is not a list.

(fn X)")
(function-put 'cl-endp 'side-effect-free 't)
(autoload 'cl-reduce "cl-seq"
"Reduce two-argument FUNCTION across SEQ.

Keywords supported:  :start :end :from-end :initial-value :key

Return the result of calling FUNCTION with the first and the
second element of SEQ, then calling FUNCTION with that result and
the third element of SEQ, then with that result and the fourth
element of SEQ, etc.

If :INITIAL-VALUE is specified, it is logically added to the
front of SEQ (or the back if :FROM-END is non-nil).  If SEQ is
empty, return :INITIAL-VALUE and FUNCTION is not called.

If SEQ is empty and no :INITIAL-VALUE is specified, then return
the result of calling FUNCTION with zero arguments.  This is the
only case where FUNCTION is called with fewer than two arguments.

If SEQ contains exactly one element and no :INITIAL-VALUE is
specified, then just return that element without calling FUNCTION.

If :FROM-END is non-nil, the reduction occurs from the back of
the SEQ moving forward, and the order of arguments to the
FUNCTION is also reversed.


(fn FUNCTION SEQ [KEYWORD VALUE]...)")
(function-put 'cl-reduce 'important-return-value 't)
(autoload 'cl-fill "cl-seq"
"Fill the elements of SEQ with ITEM.

Keywords supported:  :start :end

(fn SEQ ITEM [KEYWORD VALUE]...)")
(autoload 'cl-replace "cl-seq"
"Replace the elements of SEQ1 with the elements of SEQ2.
SEQ1 is destructively modified, then returned.

Keywords supported:  :start1 :end1 :start2 :end2

(fn SEQ1 SEQ2 [KEYWORD VALUE]...)")
(autoload 'cl-remove "cl-seq"
"Remove all occurrences of ITEM in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :test :test-not :key :count :start :end :from-end

(fn ITEM SEQ [KEYWORD VALUE]...)")
(function-put 'cl-remove 'important-return-value 't)
(autoload 'cl-remove-if "cl-seq"
"Remove all items satisfying PREDICATE in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :key :count :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-remove-if 'important-return-value 't)
(autoload 'cl-remove-if-not "cl-seq"
"Remove all items not satisfying PREDICATE in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :key :count :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-remove-if-not 'important-return-value 't)
(autoload 'cl-delete "cl-seq"
"Remove all occurrences of ITEM in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :test :test-not :key :count :start :end :from-end

(fn ITEM SEQ [KEYWORD VALUE]...)")
(function-put 'cl-delete 'important-return-value 't)
(autoload 'cl-delete-if "cl-seq"
"Remove all items satisfying PREDICATE in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :key :count :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-delete-if 'important-return-value 't)
(autoload 'cl-delete-if-not "cl-seq"
"Remove all items not satisfying PREDICATE in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :key :count :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-delete-if-not 'important-return-value 't)
(autoload 'cl-remove-duplicates "cl-seq"
"Return a copy of SEQ with all duplicate elements removed.

Keywords supported:  :test :test-not :key :start :end :from-end

(fn SEQ [KEYWORD VALUE]...)")
(function-put 'cl-remove-duplicates 'important-return-value 't)
(autoload 'cl-delete-duplicates "cl-seq"
"Remove all duplicate elements from SEQ (destructively).

Keywords supported:  :test :test-not :key :start :end :from-end

(fn SEQ [KEYWORD VALUE]...)")
(function-put 'cl-delete-duplicates 'important-return-value 't)
(autoload 'cl-substitute "cl-seq"
"Substitute NEW for OLD in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :test :test-not :key :count :start :end :from-end

(fn NEW OLD SEQ [KEYWORD VALUE]...)")
(function-put 'cl-substitute 'important-return-value 't)
(autoload 'cl-substitute-if "cl-seq"
"Substitute NEW for all items satisfying PREDICATE in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :key :count :start :end :from-end

(fn NEW PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-substitute-if 'important-return-value 't)
(autoload 'cl-substitute-if-not "cl-seq"
"Substitute NEW for all items not satisfying PREDICATE in SEQ.
This is a non-destructive function; it makes a copy of SEQ if necessary
to avoid corrupting the original SEQ.

Keywords supported:  :key :count :start :end :from-end

(fn NEW PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-substitute-if-not 'important-return-value 't)
(autoload 'cl-nsubstitute "cl-seq"
"Substitute NEW for OLD in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :test :test-not :key :count :start :end :from-end

(fn NEW OLD SEQ [KEYWORD VALUE]...)")
(function-put 'cl-nsubstitute 'important-return-value 't)
(autoload 'cl-nsubstitute-if "cl-seq"
"Substitute NEW for all items satisfying PREDICATE in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :key :count :start :end :from-end

(fn NEW PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-nsubstitute-if 'important-return-value 't)
(autoload 'cl-nsubstitute-if-not "cl-seq"
"Substitute NEW for all items not satisfying PREDICATE in SEQ.
This is a destructive function; it reuses the storage of SEQ whenever possible.

Keywords supported:  :key :count :start :end :from-end

(fn NEW PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-nsubstitute-if-not 'important-return-value 't)
(autoload 'cl-find "cl-seq"
"Find the first occurrence of ITEM in SEQ.
Return the matching ITEM, or nil if not found.

Keywords supported:  :test :test-not :key :start :end :from-end

(fn ITEM SEQ [KEYWORD VALUE]...)")
(function-put 'cl-find 'important-return-value 't)
(autoload 'cl-find-if "cl-seq"
"Find the first item satisfying PREDICATE in SEQ.
Return the matching item, or nil if not found.

Keywords supported:  :key :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-find-if 'important-return-value 't)
(autoload 'cl-find-if-not "cl-seq"
"Find the first item not satisfying PREDICATE in SEQ.
Return the matching item, or nil if not found.

Keywords supported:  :key :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-find-if-not 'important-return-value 't)
(autoload 'cl-position "cl-seq"
"Find the first occurrence of ITEM in SEQ.
Return the index of the matching item, or nil if not found.

Keywords supported:  :test :test-not :key :start :end :from-end

(fn ITEM SEQ [KEYWORD VALUE]...)")
(function-put 'cl-position 'important-return-value 't)
(autoload 'cl-position-if "cl-seq"
"Find the first item satisfying PREDICATE in SEQ.
Return the index of the matching item, or nil if not found.

Keywords supported:  :key :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-position-if 'important-return-value 't)
(autoload 'cl-position-if-not "cl-seq"
"Find the first item not satisfying PREDICATE in SEQ.
Return the index of the matching item, or nil if not found.

Keywords supported:  :key :start :end :from-end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-position-if-not 'important-return-value 't)
(autoload 'cl-count "cl-seq"
"Count the number of occurrences of ITEM in SEQ.

Keywords supported:  :test :test-not :key :start :end

(fn ITEM SEQ [KEYWORD VALUE]...)")
(function-put 'cl-count 'important-return-value 't)
(autoload 'cl-count-if "cl-seq"
"Count the number of items satisfying PREDICATE in SEQ.

Keywords supported:  :key :start :end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-count-if 'important-return-value 't)
(autoload 'cl-count-if-not "cl-seq"
"Count the number of items not satisfying PREDICATE in SEQ.

Keywords supported:  :key :start :end

(fn PREDICATE SEQ [KEYWORD VALUE]...)")
(function-put 'cl-count-if-not 'important-return-value 't)
(autoload 'cl-mismatch "cl-seq"
"Compare SEQ1 with SEQ2, return index of first mismatching element.
Return nil if the sequences match.  If one sequence is a prefix of the
other, the return value indicates the end of the shorter sequence.

Keywords supported:  :test :test-not :key :start1 :end1 :start2 :end2 :from-end

(fn SEQ1 SEQ2 [KEYWORD VALUE]...)")
(function-put 'cl-mismatch 'important-return-value 't)
(autoload 'cl-search "cl-seq"
"Search for SEQ1 as a subsequence of SEQ2.
Return the index of the leftmost element of the first match found;
return nil if there are no matches.

Keywords supported:  :test :test-not :key :start1 :end1 :start2 :end2 :from-end

(fn SEQ1 SEQ2 [KEYWORD VALUE]...)")
(function-put 'cl-search 'important-return-value 't)
(autoload 'cl-sort "cl-seq"
"Sort the argument SEQ according to PREDICATE.
This is a destructive function; it reuses the storage of SEQ if possible.

Keywords supported:  :key

(fn SEQ PREDICATE [KEYWORD VALUE]...)")
(function-put 'cl-sort 'important-return-value 't)
(autoload 'cl-stable-sort "cl-seq"
"Sort the argument SEQ stably according to PREDICATE.
This is a destructive function; it reuses the storage of SEQ if possible.

Keywords supported:  :key

(fn SEQ PREDICATE [KEYWORD VALUE]...)")
(function-put 'cl-stable-sort 'important-return-value 't)
(autoload 'cl-merge "cl-seq"
"Destructively merge the two sequences to produce a new sequence.
TYPE is the sequence type to return, SEQ1 and SEQ2 are the two argument
sequences, and PREDICATE is a `less-than' predicate on the elements.

Keywords supported:  :key

(fn TYPE SEQ1 SEQ2 PREDICATE [KEYWORD VALUE]...)")
(function-put 'cl-merge 'important-return-value 't)
(autoload 'cl-member "cl-seq"
"Find the first occurrence of ITEM in LIST.
Return the sublist of LIST whose car is ITEM.

Keywords supported:  :test :test-not :key

(fn ITEM LIST [KEYWORD VALUE]...)")
(function-put 'cl-member 'important-return-value 't)
(function-put 'cl-member 'compiler-macro #'cl--compiler-macro-member)
(autoload 'cl-member-if "cl-seq"
"Find the first item satisfying PREDICATE in LIST.
Return the sublist of LIST whose car matches.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-member-if 'important-return-value 't)
(autoload 'cl-member-if-not "cl-seq"
"Find the first item not satisfying PREDICATE in LIST.
Return the sublist of LIST whose car matches.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-member-if-not 'important-return-value 't)
(autoload 'cl--adjoin "cl-seq"
"

(fn ITEM LIST &rest CL-KEYS)")
(autoload 'cl-assoc "cl-seq"
"Find the first item whose car matches ITEM in LIST.

Keywords supported:  :test :test-not :key

(fn ITEM LIST [KEYWORD VALUE]...)")
(function-put 'cl-assoc 'important-return-value 't)
(function-put 'cl-assoc 'compiler-macro #'cl--compiler-macro-assoc)
(autoload 'cl-assoc-if "cl-seq"
"Find the first item whose car satisfies PREDICATE in LIST.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-assoc-if 'important-return-value 't)
(autoload 'cl-assoc-if-not "cl-seq"
"Find the first item whose car does not satisfy PREDICATE in LIST.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-assoc-if-not 'important-return-value 't)
(autoload 'cl-rassoc "cl-seq"
"Find the first item whose cdr matches ITEM in LIST.

Keywords supported:  :test :test-not :key

(fn ITEM LIST [KEYWORD VALUE]...)")
(function-put 'cl-rassoc 'important-return-value 't)
(autoload 'cl-rassoc-if "cl-seq"
"Find the first item whose cdr satisfies PREDICATE in LIST.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-rassoc-if 'important-return-value 't)
(autoload 'cl-rassoc-if-not "cl-seq"
"Find the first item whose cdr does not satisfy PREDICATE in LIST.

Keywords supported:  :key

(fn PREDICATE LIST [KEYWORD VALUE]...)")
(function-put 'cl-rassoc-if-not 'important-return-value 't)
(autoload 'cl-union "cl-seq"
"Combine LIST1 and LIST2 using a set-union operation.
The resulting list contains all items that appear in either LIST1 or LIST2.
This is a non-destructive function; it makes a copy of the data if necessary
to avoid corrupting the original LIST1 and LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-union 'important-return-value 't)
(autoload 'cl-nunion "cl-seq"
"Combine LIST1 and LIST2 using a set-union operation.
The resulting list contains all items that appear in either LIST1 or LIST2.
This is a destructive function; it reuses the storage of LIST1 and LIST2
whenever possible.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-nunion 'important-return-value 't)
(autoload 'cl-intersection "cl-seq"
"Combine LIST1 and LIST2 using a set-intersection operation.
The resulting list contains all items that appear in both LIST1 and LIST2.
This is a non-destructive function; it makes a copy of the data if necessary
to avoid corrupting the original LIST1 and LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-intersection 'important-return-value 't)
(autoload 'cl-nintersection "cl-seq"
"Combine LIST1 and LIST2 using a set-intersection operation.
The resulting list contains all items that appear in both LIST1 and LIST2.
This is a destructive function; it reuses the storage of LIST1 (but not
LIST2) whenever possible.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-nintersection 'important-return-value 't)
(autoload 'cl-set-difference "cl-seq"
"Combine LIST1 and LIST2 using a set-difference operation.
The resulting list contains all items that appear in LIST1 but not LIST2.
This is a non-destructive function; it makes a copy of the data if necessary
to avoid corrupting the original LIST1 and LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-set-difference 'important-return-value 't)
(autoload 'cl-nset-difference "cl-seq"
"Combine LIST1 and LIST2 using a set-difference operation.
The resulting list contains all items that appear in LIST1 but not LIST2.
This is a destructive function; it reuses the storage of LIST1 (but not
LIST2) whenever possible.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-nset-difference 'important-return-value 't)
(autoload 'cl-set-exclusive-or "cl-seq"
"Combine LIST1 and LIST2 using a set-exclusive-or operation.
The resulting list contains all items appearing in exactly one of LIST1, LIST2.
This is a non-destructive function; it makes a copy of the data if necessary
to avoid corrupting the original LIST1 and LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-set-exclusive-or 'important-return-value 't)
(autoload 'cl-nset-exclusive-or "cl-seq"
"Combine LIST1 and LIST2 using a set-exclusive-or operation.
The resulting list contains all items appearing in exactly one of LIST1, LIST2.
This is a destructive function; it reuses the storage of LIST1 and LIST2
whenever possible.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-nset-exclusive-or 'important-return-value 't)
(autoload 'cl-subsetp "cl-seq"
"Return true if LIST1 is a subset of LIST2.
I.e., if every element of LIST1 also appears in LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)")
(function-put 'cl-subsetp 'important-return-value 't)
(autoload 'cl-subst-if "cl-seq"
"Substitute NEW for elements matching PREDICATE in TREE (non-destructively).
Return a copy of TREE with all matching elements replaced by NEW.

Keywords supported:  :key

(fn NEW PREDICATE TREE [KEYWORD VALUE]...)")
(function-put 'cl-subst-if 'important-return-value 't)
(autoload 'cl-subst-if-not "cl-seq"
"Substitute NEW for elts not matching PREDICATE in TREE (non-destructively).
Return a copy of TREE with all non-matching elements replaced by NEW.

Keywords supported:  :key

(fn NEW PREDICATE TREE [KEYWORD VALUE]...)")
(function-put 'cl-subst-if-not 'important-return-value 't)
(autoload 'cl-nsubst "cl-seq"
"Substitute NEW for OLD everywhere in TREE (destructively).
Any element of TREE which is `eql' to OLD is changed to NEW (via a call
to `setcar').

Keywords supported:  :test :test-not :key

(fn NEW OLD TREE [KEYWORD VALUE]...)")
(function-put 'cl-nsubst 'important-return-value 't)
(autoload 'cl-nsubst-if "cl-seq"
"Substitute NEW for elements matching PREDICATE in TREE (destructively).
Any element of TREE which matches is changed to NEW (via a call to `setcar').

Keywords supported:  :key

(fn NEW PREDICATE TREE [KEYWORD VALUE]...)")
(function-put 'cl-nsubst-if 'important-return-value 't)
(autoload 'cl-nsubst-if-not "cl-seq"
"Substitute NEW for elements not matching PREDICATE in TREE (destructively).
Any element of TREE which matches is changed to NEW (via a call to `setcar').

Keywords supported:  :key

(fn NEW PREDICATE TREE [KEYWORD VALUE]...)")
(function-put 'cl-nsubst-if-not 'important-return-value 't)
(autoload 'cl-sublis "cl-seq"
"Perform substitutions indicated by ALIST in TREE (non-destructively).
Return a copy of TREE with all matching elements replaced.

Keywords supported:  :test :test-not :key

(fn ALIST TREE [KEYWORD VALUE]...)")
(function-put 'cl-sublis 'important-return-value 't)
(autoload 'cl-nsublis "cl-seq"
"Perform substitutions indicated by ALIST in TREE (destructively).
Any matching element of TREE is changed via a call to `setcar'.

Keywords supported:  :test :test-not :key

(fn ALIST TREE [KEYWORD VALUE]...)")
(function-put 'cl-nsublis 'important-return-value 't)
(autoload 'cl-tree-equal "cl-seq"
"Return t if trees TREE1 and TREE2 have `eql' leaves.
Atoms are compared by `eql'; cons cells are compared recursively.

Keywords supported:  :test :test-not :key

(fn TREE1 TREE2 [KEYWORD VALUE]...)")
(function-put 'cl-tree-equal 'important-return-value 't)

;;; End of scraped data

(provide 'cl-loaddefs)

;; Local Variables:
;; version-control: never
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; cl-loaddefs.el ends here
